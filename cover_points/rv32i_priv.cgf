#####################################################################################################################################################################################
# These coverpoints belongs to the test plan for RISC-V Privilege Arch Compliance developed by 10xEngineers
#####################################################################################################################################################################################

ecall:
  config: 
    - check ISA:=regex(.*I.*); def rvtest_mtrap_routine=True 
  mnemonics: 
    ecall: 0

ebreak:
  config: 
    - check ISA:=regex(.*I.*); def rvtest_mtrap_routine=True 
  mnemonics: 
    ebreak: 0

#####################################################################################################################################################################################
     
misa:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*F.*D); 
  mnemonics:
     - csrrw
  csr_comb:
	(misa & 0x08) | (misa & 0x20) == 0 : 0		# setting “F”=0 and “D”=1 should results in both “F” and “D” being cleared.
  val_comb:
	rs1val & (0x08) == 0x08 and (imm_val == 0x301): 0	# checks if the third bit of rs1val is set to 1 and if imm_val is equal to 0x301. If these conditions are both true, the coverpoint will have a value of 0.	


misa_mxl_check_32:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x01 : 0				# checks whether the mxl field of misa register is 1.
    
    
misa_mxl_check_64:
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x02 : 0				# checks whether the mxl field of misa register is 2.
    
    
misa_mxl_check_128:
  config: 
    - check ISA:=regex(.*128.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x03 : 0				# checks whether the mxl field of misa register is 3.

#####################################################################################################################################################################################

mstatus:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mstatus & 0x1 == 0x1 : 0 				# checks whether machine-mode interrupts are enabled or disabled.
	mstatus & 0x2 == 0x2 : 0 				# checks whether machine-mode memory access protection is enabled or disabled.
	mstatus & 0x4 == 0x4 : 0 				# checks whether machine-mode floating point exceptions are enabled or disabled.
	mstatus & 0x40 == 0x40 : 0 				# checks whether machine-mode previous privilege mode is set to machine mode.
	mstatus & 0x80 == 0x80 : 0 				# checks whether machine-mode previous interrupt enable is set to enabled.
	mstatus & 0x100 == 0x100 : 0 				# checks whether machine-mode previous interrupt enable is set to disabled.
	mstatus & 0x200 == 0x200 : 0				# checks whether machine-mode previous floating point enable is set to enabled.
	mstatus & 0x400 == 0x400 : 0				# checks whether machine-mode previous floating point enable is set to disabled.
	mstatus & 0x800 == 0x800 : 0				# checks whether machine-mode previous timer interrupt pending is set to pending.
	mstatus & 0x1000 == 0x1000 : 0			# checks whether machine-mode previous timer interrupt pending is set to not pending.
	mstatus & 0x2000 == 0x2000 : 0			# checks whether machine-mode previous external interrupt pending is set to pending.
	mstatus & 0x4000 == 0x4000 : 0			# checks whether machine-mode previous external interrupt pending is set to not pending.
	mstatus & 0x8000 == 0x8000 : 0			# checks whether machine-mode previous virtual memory enabled is set to enabled.
	mstatus & 0x10000 == 0x10000 : 0			# checks whether machine-mode previous virtual memory enabled is set to disabled.
	mstatus & 0x20000 == 0x20000 : 0			# checks whether machine-mode previous floating point enabled is set to enabled.
	mstatus & 0x40000 == 0x40000 : 0			# checks whether machine-mode previous floating point enabled is set to disabled.
	mstatus & 0x80000 == 0x80000 : 0			# checks whether machine-mode previous floating point traps are enabled or disabled.
	mstatus & 0x100000 == 0x100000 : 0			# checks whether machine-mode previous floating point underflow traps are enabled or disabled.
	mstatus & 0x200000 == 0x200000 : 0			# checks whether machine-mode previous floating point overflow traps are enabled or disabled.
	mstatus & 0x400000 == 0x400000 : 0			# checks whether machine-mode previous floating point invalid operation traps are enabled or disabled.
	mstatus & 0x800000 == 0x800000 : 0			# checks whether machine-mode previous floating point division by zero traps are enabled or disabled.
	(mstatus >> (xlen-1)) & (mstatus >> (xlen-2)) & (mstatus >> (xlen-3)) == 0		# If all of these bits are set to 1, the coverpoint will evaluate to 0, indicating that the processor is in supervisor mode with memory access protection and floating point exceptions enabled

mstatus_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatus >> 1) & 0x01 == 0x01 : 0			# checks if the SIE gets enabled
	(mstatus >> 5) & 0x01 == 0x01 : 0 			# checks SPIE bit 
	(mstatus >> 8) & 0x01 == 0x01 : 0 			# checks SPP bit
	(mstatus >> 22) & 0x1 == 0x01 : 0 			# When TSR=1, attempts to execute SRET while executing in S-mode will raise an illegal instruction exception.  
	(mstatus >> 10) & 0x3 == 0x01 : 0			# MPP fields to check if privilege mode is S
	(mstatus >> 18) & 0x1 == 0x01 : 0 			# checks when SUM=1, accesses to pages that are accessible by U-mode are permitted.
	mstatus & 0x20 == 0x20 : 0 				# checks whether machine-mode previous privilege mode is set to supervisor mode.
	mstatus & 0x8 == 0x8 : 0 				# checks whether machine-mode supervisor mode is enabled or disabled.
	
mstatus_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mstatus & 0x10 == 0x10 : 0 				# checks whether machine-mode previous privilege mode is set to user mode.
	
	
mstatush:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 5) & 0x1 == 0x01 : 0			# checks if machine-mode byte enable (MBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that MBE is enabled
	(mstatush >> 6) & 0x1 == 0x01 : 0			# checks if machine-mode user byte enable (UBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that UBE is enabled
	(mstatush >> 7) & 0x1 == 0x01 : 0			# checks if machine-mode supervisor timer interrupt enable is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that supervisor timer interrupt enable is enabled
	(mstatush >> 8) & 0x1 == 0x01 : 0			# checks if machine-mode previous supervisor timer interrupt enable is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that previous supervisor timer interrupt enable is enabled


mstatus_little-endian:    
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 5) & (mstatus >> 4) & (mstatus >> 6) == 0 : 0 		# checks if all three of these bits are set to 0, indicating that MBE, SBE, and UBE are all disabled. When these bits are all disabled, the processor is in little-endian mode, and accesses made to memory will be little-endian.


mstatus_big_endian:    
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*S.*); check big_endian_support=True; 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 4) & 0x1 == 0x01 : 0 			# ensures that certain instructions or operations are only executed when the processor is in supervisor mode and in big-endian mode 
	(mstatus >> 37) & 0x1 == 0x01 : 0 			# checks the sixth least significant bit of the upper 32 bits of the mstatus register to ensure that machine-mode byte enable (MBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that MBE is enabled 

	(mstatus >> 38) & 0x1 == 0x01 : 0 			# checks the seventh least significant bit of the upper 32 bits of the mstatus register to ensure that machine-mode user byte enable (UBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that UBE is enabled

	(mstatus >> 39) & 0x1 == 0x01 : 0 			# checks the eighth least significant bit of the upper 32 bits of the mstatus register to ensure that machine-mode supervisor timer interrupt enable is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that supervisor timer interrupt enable is enabled								   


mstatus_checking_SD:    
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); 
  csr_comb: 
    	mstatus >> (xlen-1) == 1 : 0 				# The SD bit is read-only and is set when either the FS, VS bits encode a Dirty state 
    	mstatus >> (xlen-1) == 0 : 0 				# The SD bit is read-only and is set when either the FS, VS bits encode a Dirty state 

    
#####################################################################################################################################################################################
    
mideleg:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mideleg >> 3) & 0x01 == 0x01 : 0 			# Machine software interrupt is pending
	(mideleg >> 7) & 0x01 == 0x01 : 0 			# Machine timer interrupt is pending
	(mideleg >> 11) & 0x1 == 0x01 : 0 			# Machine external interrupt is pending
	(mideleg >> 1) & 0x01 == 0x01 : 0 			# Machine software interrupt is masked
	(mideleg >> 5) & 0x01 == 0x01 : 0 			# Machine timer interrupt is masked
	(mideleg >> 9) & 0x1 == 0x01 : 0 			# Machine external interrupt is masked
	mideleg == 0x0000 : 0 					# All interrupts are unmasked and no interrupts are pending
	mideleg == 0x000F : 0 					# All interrupts are masked and no interrupts are pending
	mideleg == 0xFF00 : 0 					# All interrupts are unmasked and all interrupts are pending
	mideleg == 0x0001 : 0 					# Machine software interrupt is pending and all other interrupts are unmasked
	mideleg == 0x0010 : 0 					# Machine timer interrupt is pending and all other interrupts are unmasked
	mideleg == 0x0100 : 0 					# Machine external interrupt is pending and all other interrupts are unmasked

#####################################################################################################################################################################################
     
medeleg:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
     medeleg & 0x10 == 0x10 : 0				# checks the bit 4 of the medeleg register to see if it is set to 1, which would indicate an environment call from M-mode
	medeleg & 0x20 == 0x20 : 0				# checks the bit 5 of the medeleg register to see if it is set to 1, which would indicate an instruction page fault
	medeleg & 0x40 == 0x40 : 0				# checks the bit 6 of the medeleg register to see if it is set to 1, which would indicate a load page fault
	medeleg & 0x80 == 0x80 : 0				# checks the bit 7 of the medeleg register to see if it is set to 1, which would indicate a store/AMO page fault
	medeleg & 0x100 == 0x100 : 0				# checks the bit 8 of the medeleg register to see if it is set to 1, which would indicate a breakpoint
	medeleg & 0x200 == 0x200 : 0				# checks the bit 9 of the medeleg register to see if it is set to 1, which would indicate a breakpoint	
	medeleg & 0x400 == 0x400 : 0				# checks the bit 10 of the medeleg register to see if it is set to 1, which would indicate a machine-mode timer interrupt	
	medeleg & 0x800 == 0x800 : 0				# checks the bit 11 of the medeleg register to see if it is set to 1, which would indicate a machine-mode external interrupt	
	medeleg & 0x1000 == 0x1000 : 0			# checks the bit 12 of the medeleg register to see if it is set to 1, which would indicate a machine-mode software interrupt	
	medeleg & 0x2000 == 0x2000 : 0			# checks the bit 13 of the medeleg register to see if it is set to 1, which would indicate a machine-mode timer interrupt
	medeleg & 0x4000 == 0x4000 : 0			# checks the bit 14 of the medeleg register to see if it is set to 1, which would indicate a machine-mode external interrupt
	medeleg & 0x8000 == 0x8000 : 0			# checks the bit 15 of the medeleg register to see if it is set to 1, which would indicate a machine-mode software interrupt			

#####################################################################################################################################################################################

mie:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mie & 0x01 == 0x01 : 0 				# Interrupts are masked
	mie & 0x01 == 0x00 : 0 				# Interrupts are not masked
	mie & 0x08 == 0x08 : 0 				# Machine software interrupt is enabled
	mie & 0x80 == 0x80 : 0 				# Machine timer interrupt is enabled
	mie & 0x800 == 0x800 : 0 				# Machine external interrupt is enabled
    
mie_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mie & 0x02 == 0x2 : 0	 				# Supervisor software interrupt is enabled
	mie & 0x20 == 0x20 : 0		 			# Supervisor timer interrupt is enabled
	mie & 0x200 == 0x200 : 0	 			# Supervisor external interrupt is enabled
    
#####################################################################################################################################################################################
    
mip:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mip & 0x7fff0000 == 0x7fff0000 : 0 			# All interrupts are pending in all privilege levels
	mip & 0x7fff0000 == 0x00000000 : 0 			# No interrupts are pending in any privilege level
	mip & 0x08 == 0x08 : 0 				# Machine software interrupt is pending
	mip & 0x80 == 0x80 : 0		 			# Machine timer interrupt is pending
	mip & 0x800 == 0x800 : 0 				# Machine external interrupt is pending

mip_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mip & 0x20 == 0x20 : 0		 			# Supervisor timer interrupt is pending
	mip & 0x02 == 0x02 : 0 	 			# Supervisor software interrupt is pending
	mip & 0x200 == 0x200 : 0  				# Supervisor external interrupt is pending

#####################################################################################################################################################################################

mcause:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause >> 31) & 1 == 1 : 0				# checks if the exception or interrupt was an interrupt 
	(mcause >> 31) & 1 == 0 : 0				# checks if the exception or interrupt was an exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h00 : 0				# Instruction address misaligned exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h01 : 0				# Instruction access fault exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h02 : 0				# Illegal instruction exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h03 : 0				# Breakpoint exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h04 : 0				# Load address misaligned exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h05 : 0				# Load access fault exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h06 : 0				# Store/AMO address misaligned exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h07 : 0				# Store/AMO access fault exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h08 : 0				# Environment call from U-mode exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h0b : 0				# Environment call from M-mode exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h0c : 0				# Instruction page fault exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h0d : 0				# Load page fault exception
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h0f : 0				# Store/AMO page fault exception
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h03 : 0				# Machine software interrupt
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h07 : 0				# Machine timer interrupt
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h0b : 0				# Machine external interrupt
	

mcause_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h01 : 0				# Supervisor software interrupt
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h05 : 0				# Supervisor timer interrupt
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h09 : 0				# Supervisor external interrupt
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h09 : 0				# Environment call from S-mode exception
	
mcause_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h08 : 0				# Environment call from U-mode exception
	

#####################################################################################################################################################################################
		
mcycle:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcycle == 0x0 : 0					# where the value in mcycle register is 0
	mcycle > 1000 : 0 					# More than 1000 cycles were executed
	mcycle > 10000 : 0					# More than 10000 cycles were executed
	mcycle > 100000 : 0					# More than 100000 cycles were executed	

#####################################################################################################################################################################################

minstret:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	minstret > 1000 : 0 					# More than 1000 instructions were executed in the last second
	minstret > 10000 : 0 					# More than 10000 instructions were executed in the last second
	minstret > 100000 : 0 					# More than 100000 instructions were executed in the last second

#####################################################################################################################################################################################

mhpmcounter:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mhpmcounter3 > 1000 : 0 				# More than 1000 memory accesses occurred
	mhpmcounter3 > 10000 : 0 				# More than 10000 memory accesses occurred
	mhpmcounter3 > 100000 : 0 				# More than 100000 memory accesses occurred

#####################################################################################################################################################################################

mhpmevent:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mhpmevent3 == 0x0 : 0					# where the value in mhpmevent3 register is 0.
	mhpmevent3 > 1000 : 0					# More than 1000 memory accesses occurred
	mhpmevent3 > 10000 : 0 				# More than 10000 memory accesses occurred
	mhpmevent3 > 100000 : 0 				# More than 100000 memory accesses occurred

#####################################################################################################################################################################################
	
mcounteren:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcounteren & 0x07 == 0x07 : 0				# checks that the three least significant bits are all 1
	mcounteren & 0x07 == 0x00 : 0				# checks that the three least significant bits are either all 0
    	mcounteren & 0x07 == 0x05 : 0				# for the next 3, checking that the three least significant bits are alternating 1s and 0s (e.g. 101, 010, or 011)
    	mcounteren & 0x07 == 0x02 : 0
    	mcounteren & 0x07 == 0x06 : 0

#####################################################################################################################################################################################

mcountinhibit:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcountinhibit == 1 : 0					# checks that the value of the register is either 1
	mcountinhibit == 1 : 0					# checks that the value of the register is either 0
	mcountinhibit != 0 : 0					# checks that the value of the register is any value other than 0

#####################################################################################################################################################################################
	
mepc:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 10) & 0x01 == 0x01 : 0 			# Exception or interrupt was caused by an instruction fetch
	(mepc >> 10) & 0x01 == 0x00 : 0 			# Exception or interrupt was caused by a data access
	(mepc >> 3) & 0x07 == 0x00 : 0 			# Exception or interrupt occurred at machine level (M-mode)
	(mepc & 0x3) == 0x00 : 0 				# Instruction was aligned on a 4-byte boundary
	(mepc & 0x3) == 0x01 : 0 				# Instruction was aligned on a 2-byte boundary
	(mepc & 0x3) == 0x02 : 0 				# Instruction was aligned on a 1-byte boundary
	(mepc & 0x3) == 0x03 : 0 				# Instruction was unaligned
	(mepc >> 2) & 0x01 == 0x00 : 0 			# Instruction was a load or store instruction
	(mepc >> 2) & 0x01 == 0x01 : 0 			# Instruction was an arithmetic or logical instruction

mepc_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 3) & 0x07 == 0x01 : 0 			# Exception or interrupt occurred at supervisor level (S-mode)
	
mepc_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 3) & 0x07 == 0x02 : 0 			# Exception or interrupt occurred at user level (U-mode)

#####################################################################################################################################################################################

mseccfg:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mseccfg >> 4) & 0x1 == 0x1 : 0			# checks that the fifth bit of the mseccfg CSR is set to 1
    	(mseccfg >> 5) & 0x1 == 0x0 : 0			# checks that the sixth bit of the mseccfg CSR is set to 0

#####################################################################################################################################################################################


pmpcfg:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  csr_comb:
    pmpcfg0 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg0
    pmpcfg0 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg0
    (pmpcfg0 >> 8) & 0x80 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg0
    (pmpcfg0 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg0
    (pmpcfg0 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg0
    (pmpcfg0 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg0
    (pmpcfg0 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg0
    (pmpcfg0 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg0
    pmpcfg1 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg1
    pmpcfg1 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg1
    (pmpcfg1 >> 8) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg1
    (pmpcfg1 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg1
    (pmpcfg1 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg1
    (pmpcfg1 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg1
    (pmpcfg1 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg1
    (pmpcfg1 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg1
    pmpcfg2 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg2
    pmpcfg2 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg2
    (pmpcfg2 >> 8) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg2
    (pmpcfg2 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg2
    (pmpcfg2 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg2
    (pmpcfg2 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg2
    (pmpcfg2 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg2
    (pmpcfg2 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg2
    pmpcfg3 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg3
    pmpcfg3 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg3
    (pmpcfg3 >> 8) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg3
    (pmpcfg3 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg3
    (pmpcfg3 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg3
    (pmpcfg3 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg3
    (pmpcfg3 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg3
    (pmpcfg3 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg3



pmptor:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  csr_comb:
    (pmpcfg0 >> 16) & 0x18 == 0x08 : 0		# Check if we are in TOR mode
    (pmpcfg0 >> 16) & 0x01 == 0x01 : 0		# Check if R=1
    (pmpcfg0 >> 16) & 0x02 == 0x02 : 0		# Check if W=1
    (pmpcfg0 >> 16) & 0x04 == 0x04 : 0		# Check if X=1
    (pmpcfg0 >> 16) & 0x01 == 0x00 : 0		# Check if R=0
    (pmpcfg0 >> 16) & 0x02 == 0x00 : 0		# Check if W=0
    (pmpcfg0 >> 16) & 0x04 == 0x00 : 0		# Check if X=0

pmpna4:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  csr_comb:
    (pmpcfg0 >> 16) & 0x18 == 0x10 : 0		# Check if we are in NA4 mode
    (pmpcfg0 >> 16) & 0x01 == 0x01 : 0		# Check if R=1
    (pmpcfg0 >> 16) & 0x02 == 0x02 : 0		# Check if W=1
    (pmpcfg0 >> 16) & 0x04 == 0x04 : 0		# Check if X=1
    (pmpcfg0 >> 16) & 0x01 == 0x00 : 0		# Check if R=0
    (pmpcfg0 >> 16) & 0x02 == 0x00 : 0		# Check if W=0
    (pmpcfg0 >> 16) & 0x04 == 0x00 : 0		# Check if X=0


pmpnapot:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
    (pmpcfg0 >> 16) & 0x18 == 0x18 : 0		# Check if we are in NAPOT Mode?
    (pmpcfg0 >> 16) & 0x01 == 0x01 : 0		# Check if R=1
    (pmpcfg0 >> 16) & 0x02 == 0x02 : 0		# Check if W=1
    (pmpcfg0 >> 16) & 0x04 == 0x04 : 0		# Check if X=1
    (pmpcfg0 >> 16) & 0x01 == 0x00 : 0		# Check if R=0
    (pmpcfg0 >> 16) & 0x02 == 0x00 : 0		# Check if W=0
    (pmpcfg0 >> 16) & 0x04 == 0x00 : 0		# Check if X=0

misalign-lh:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  mnemonics:
    lh: 0
  val_comb:
    'ea_align == 1': 0

misalign-lhu:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    lhu: 0
  val_comb:
    'ea_align == 1': 0


misalign-lw:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    lw: 0
  val_comb:
    'ea_align == 1': 0
    'ea_align == 2': 0
    'ea_align == 3': 0

misalign-sh:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    sh: 0
  val_comb:
    'ea_align == 1': 0

misalign-sw:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    sw: 0
  val_comb:
    'ea_align == 1': 0
    'ea_align == 2': 0
    'ea_align == 3': 0

misalign2-jalr:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    jalr: 0
  val_comb:
    'imm_val%2 == 1 and ea_align == 2': 0


misalign1-jalr:
  config: 
    - check ISA:=regex(.*I.*)
  mnemonics:
    jalr: 0
  val_comb:
    'imm_val%2 == 0 and ea_align == 1': 0


misalign-jal:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    jal: 0
  val_comb:
    'ea_align == 2': 0

misalign-bge:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bge: 0
  val_comb:
    ' rs1_val>rs2_val and ea_align == 2': 0

misalign-bgeu:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bgeu: 0
  val_comb:
    ' rs1_val>rs2_val and ea_align == 2': 0

misalign-blt:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    blt: 0
  val_comb:
    ' rs1_val<rs2_val and ea_align == 2': 0

misalign-bltu:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bltu: 0
  val_comb:
    ' rs1_val<rs2_val and ea_align == 2': 0

misalign-bne:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bne: 0
  val_comb:
    ' rs1_val!=rs2_val and ea_align == 2': 0

misalign-beq:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    beq: 0
  val_comb:
    ' rs1_val==rs2_val and ea_align == 2': 0
