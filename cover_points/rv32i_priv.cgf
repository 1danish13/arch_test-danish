#####################################################################################################################################################################################
# These coverpoints belongs to the test plan for RISC-V Privilege Arch Compliance developed by 10xEngineers
#####################################################################################################################################################################################

ecall:
  config: 
    - check ISA:=regex(.*I.*); def rvtest_mtrap_routine=True 
  mnemonics: 
    ecall: 0

ebreak:
  config: 
    - check ISA:=regex(.*I.*); def rvtest_mtrap_routine=True 
  mnemonics: 
    ebreak: 0

#####################################################################################################################################################################################
     
misa:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*F.*D); 
  mnemonics:
     - csrrw
  csr_comb:
	(misa & 0x08) | (misa & 0x20) == 0 : 0		# setting “F”=0 and “D”=1 should results in both “F” and “D” being cleared.
  val_comb:
	rs1val & (0x08) == 0x08 and (imm_val == 0x301): 0	# checks if the third bit of rs1val is set to 1 and if imm_val is equal to 0x301. If these conditions are both true, the coverpoint will have a value of 0.	


misa_mxl_check_32:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x01 : 0				# checks whether the mxl field of misa register is 1.
    
    
misa_mxl_check_64:
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x02 : 0				# checks whether the mxl field of misa register is 2.
    
    
misa_mxl_check_128:
  config: 
    - check ISA:=regex(.*128.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x03 : 0				# checks whether the mxl field of misa register is 3.

#####################################################################################################################################################################################

mstatus:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mstatus & 0x1 == 0x1 : 0 				# checks whether machine-mode interrupts are enabled or disabled.
	mstatus & 0x2 == 0x2 : 0 				# checks whether machine-mode memory access protection is enabled or disabled.
	mstatus & 0x4 == 0x4 : 0 				# checks whether machine-mode floating point exceptions are enabled or disabled.
	mstatus & 0x40 == 0x40 : 0 				# checks whether machine-mode previous privilege mode is set to machine mode.
	mstatus & 0x80 == 0x80 : 0 				# checks whether machine-mode previous interrupt enable is set to enabled.
	mstatus & 0x100 == 0x100 : 0 				# checks whether machine-mode previous interrupt enable is set to disabled.
	mstatus & 0x200 == 0x200 : 0				# checks whether machine-mode previous floating point enable is set to enabled.
	mstatus & 0x400 == 0x400 : 0				# checks whether machine-mode previous floating point enable is set to disabled.
	mstatus & 0x800 == 0x800 : 0				# checks whether machine-mode previous timer interrupt pending is set to pending.
	mstatus & 0x1000 == 0x1000 : 0			# checks whether machine-mode previous timer interrupt pending is set to not pending.
	mstatus & 0x2000 == 0x2000 : 0			# checks whether machine-mode previous external interrupt pending is set to pending.
	mstatus & 0x4000 == 0x4000 : 0			# checks whether machine-mode previous external interrupt pending is set to not pending.
	mstatus & 0x8000 == 0x8000 : 0			# checks whether machine-mode previous virtual memory enabled is set to enabled.
	mstatus & 0x10000 == 0x10000 : 0			# checks whether machine-mode previous virtual memory enabled is set to disabled.
	mstatus & 0x20000 == 0x20000 : 0			# checks whether machine-mode previous floating point enabled is set to enabled.
	mstatus & 0x40000 == 0x40000 : 0			# checks whether machine-mode previous floating point enabled is set to disabled.
	mstatus & 0x80000 == 0x80000 : 0			# checks whether machine-mode previous floating point traps are enabled or disabled.
	mstatus & 0x100000 == 0x100000 : 0			# checks whether machine-mode previous floating point underflow traps are enabled or disabled.
	mstatus & 0x200000 == 0x200000 : 0			# checks whether machine-mode previous floating point overflow traps are enabled or disabled.
	mstatus & 0x400000 == 0x400000 : 0			# checks whether machine-mode previous floating point invalid operation traps are enabled or disabled.
	mstatus & 0x800000 == 0x800000 : 0			# checks whether machine-mode previous floating point division by zero traps are enabled or disabled.
	(mstatus >> (xlen-1)) & (mstatus >> (xlen-2)) & (mstatus >> (xlen-3)) == 0		# If all of these bits are set to 1, the coverpoint will evaluate to 0, indicating that the processor is in supervisor mode with memory access protection and floating point exceptions enabled

mstatus_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatus >> 1) & 0x01 == 0x01 : 0			# checks if the SIE gets enabled
	(mstatus >> 5) & 0x01 == 0x01 : 0 			# checks SPIE bit 
	(mstatus >> 8) & 0x01 == 0x01 : 0 			# checks SPP bit
	(mstatus >> 22) & 0x1 == 0x01 : 0 			# When TSR=1, attempts to execute SRET while executing in S-mode will raise an illegal instruction exception.  
	(mstatus >> 10) & 0x3 == 0x01 : 0			# MPP fields to check if privilege mode is S
	(mstatus >> 18) & 0x1 == 0x01 : 0 			# checks when SUM=1, accesses to pages that are accessible by U-mode are permitted.
	mstatus & 0x20 == 0x20 : 0 				# checks whether machine-mode previous privilege mode is set to supervisor mode.
	mstatus & 0x8 == 0x8 : 0 				# checks whether machine-mode supervisor mode is enabled or disabled.
	
mstatus_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mstatus & 0x10 == 0x10 : 0 				# checks whether machine-mode previous privilege mode is set to user mode.
	
	
mstatush:    
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 5) & 0x1 == 0x01 : 0			# checks if machine-mode byte enable (MBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that MBE is enabled
	(mstatush >> 6) & 0x1 == 0x01 : 0			# checks if machine-mode user byte enable (UBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that UBE is enabled
	(mstatush >> 7) & 0x1 == 0x01 : 0			# checks if machine-mode supervisor timer interrupt enable is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that supervisor timer interrupt enable is enabled
	(mstatush >> 8) & 0x1 == 0x01 : 0			# checks if machine-mode previous supervisor timer interrupt enable is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that previous supervisor timer interrupt enable is enabled


mstatus_little-endian:    
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 5) & (mstatus >> 4) & (mstatus >> 6) == 0 : 0 		# checks if all three of these bits are set to 0, indicating that MBE, SBE, and UBE are all disabled. When these bits are all disabled, the processor is in little-endian mode, and accesses made to memory will be little-endian.


mstatus_big_endian:    
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*S.*); check big_endian_support=True; 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 4) & 0x1 == 0x01 : 0 			# ensures that certain instructions or operations are only executed when the processor is in supervisor mode and in big-endian mode 
	(mstatus >> 37) & 0x1 == 0x01 : 0 			# checks the sixth least significant bit of the upper 32 bits of the mstatus register to ensure that machine-mode byte enable (MBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that MBE is enabled 

	(mstatus >> 38) & 0x1 == 0x01 : 0 			# checks the seventh least significant bit of the upper 32 bits of the mstatus register to ensure that machine-mode user byte enable (UBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that UBE is enabled

	(mstatus >> 39) & 0x1 == 0x01 : 0 			# checks the eighth least significant bit of the upper 32 bits of the mstatus register to ensure that machine-mode supervisor timer interrupt enable is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that supervisor timer interrupt enable is enabled								   


mstatus_checking_SD:    
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); 
  csr_comb: 
    	mstatus >> (xlen-1) == 1 : 0 				# The SD bit is read-only and is set when either the FS, VS bits encode a Dirty state 
    	mstatus >> (xlen-1) == 0 : 0 				# The SD bit is read-only and is set when either the FS, VS bits encode a Dirty state 


#####################################################################################################################################################################################
      
mtvec:  
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mtvec & 0x02 == 0x02 : 0 				# This coverpoint checks the second least significant bit of the mtvec register to see if it is set to 1.
	mtvec & 0x04 == 0x04 : 0  				# This coverpoint checks the third least significant bit of the mtvec register to see if it is set to 1.
	mtvec & 0x08 == 0x08 : 0  				# This coverpoint checks the fourth least significant bit of the mtvec register to see if it is set to 1.
	mtvec & 0x10 == 0x10 : 0  				# This coverpoint checks the fifth least significant bit of the mtvec register to see if it is set to 1.
	mtvec & 0x20 == 0x20 : 0  				# This coverpoint checks the sixth least significant bit of the mtvec register to see if it is set to 1.
	mtvec & 0x40 == 0x40 : 0  				# This coverpoint checks the seventh least significant bit of the mtvec register to see if it is set to 1.
	mtvec & 0x80 == 0x80 : 0  				# This coverpoint checks the eighth least significant bit of the mtvec register to see if it is set to 1.
    
#####################################################################################################################################################################################
    
mideleg:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mideleg >> 3) & 0x01 == 0x01 : 0 			# Machine software interrupt is pending
	(mideleg >> 7) & 0x01 == 0x01 : 0 			# Machine timer interrupt is pending
	(mideleg >> 11) & 0x1 == 0x01 : 0 			# Machine external interrupt is pending
	(mideleg >> 1) & 0x01 == 0x01 : 0 			# Machine software interrupt is masked
	(mideleg >> 5) & 0x01 == 0x01 : 0 			# Machine timer interrupt is masked
	(mideleg >> 9) & 0x1 == 0x01 : 0 			# Machine external interrupt is masked
	mideleg == 0x0000 : 0 					# All interrupts are unmasked and no interrupts are pending
	mideleg == 0x000F : 0 					# All interrupts are masked and no interrupts are pending
	mideleg == 0xFF00 : 0 					# All interrupts are unmasked and all interrupts are pending
	mideleg == 0x0001 : 0 					# Machine software interrupt is pending and all other interrupts are unmasked
	mideleg == 0x0010 : 0 					# Machine timer interrupt is pending and all other interrupts are unmasked
	mideleg == 0x0100 : 0 					# Machine external interrupt is pending and all other interrupts are unmasked

#####################################################################################################################################################################################
     
medeleg:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
     medeleg & 0x10 == 0x10 : 0				# checks the bit 4 of the medeleg register to see if it is set to 1, which would indicate an environment call from M-mode
	medeleg & 0x20 == 0x20 : 0				# checks the bit 5 of the medeleg register to see if it is set to 1, which would indicate an instruction page fault
	medeleg & 0x40 == 0x40 : 0				# checks the bit 6 of the medeleg register to see if it is set to 1, which would indicate a load page fault
	medeleg & 0x80 == 0x80 : 0				# checks the bit 7 of the medeleg register to see if it is set to 1, which would indicate a store/AMO page fault
	medeleg & 0x100 == 0x100 : 0				# checks the bit 8 of the medeleg register to see if it is set to 1, which would indicate a breakpoint
	medeleg & 0x200 == 0x200 : 0				# checks the bit 9 of the medeleg register to see if it is set to 1, which would indicate a breakpoint	
	medeleg & 0x400 == 0x400 : 0				# checks the bit 10 of the medeleg register to see if it is set to 1, which would indicate a machine-mode timer interrupt	
	medeleg & 0x800 == 0x800 : 0				# checks the bit 11 of the medeleg register to see if it is set to 1, which would indicate a machine-mode external interrupt	
	medeleg & 0x1000 == 0x1000 : 0			# checks the bit 12 of the medeleg register to see if it is set to 1, which would indicate a machine-mode software interrupt	
	medeleg & 0x2000 == 0x2000 : 0			# checks the bit 13 of the medeleg register to see if it is set to 1, which would indicate a machine-mode timer interrupt
	medeleg & 0x4000 == 0x4000 : 0			# checks the bit 14 of the medeleg register to see if it is set to 1, which would indicate a machine-mode external interrupt
	medeleg & 0x8000 == 0x8000 : 0			# checks the bit 15 of the medeleg register to see if it is set to 1, which would indicate a machine-mode software interrupt			

#####################################################################################################################################################################################

mie:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mie & 0x01 == 0x01 : 0 				# Interrupts are masked
	mie & 0x01 == 0x00 : 0 				# Interrupts are not masked
	mie == 0xffffffff : 0 					# All interrupt sources are enabled
	mie == 0x00000000 : 0 					# All interrupt sources are disabled
	mie & 0x80000 == 0x80000 : 0 				# Machine software interrupt is enabled
	mie & 0x400000 == 0x400000 : 0 			# Machine timer interrupt is enabled
	mie & 0x2000000 == 0x2000000 : 0 			# Machine external interrupt is enabled
    
mie_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mie & 0x40000 == 0x40000 : 0 				# Supervisor software interrupt is enabled
	mie & 0x200000 == 0x200000 : 0 			# Supervisor timer interrupt is enabled
	mie & 0x1000000 == 0x1000000 : 0 			# Supervisor external interrupt is enabled
	
mie_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mie & 0x800000 == 0x800000 : 0 			# User external interrupt is enabled
	mie & 0x100000 == 0x100000 : 0 			# User timer interrupt is enabled
	mie & 0x20000 == 0x20000 : 0 				# User software interrupt is enabled
    
#####################################################################################################################################################################################
    
mip:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mip == 0xffffffff : 0 					# All interrupt sources are pending
	mip & 0x7fff0000 == 0x7fff0000 : 0 			# All interrupts are pending in all privilege levels
	mip & 0x7fff0000 == 0x00000000 : 0 			# No interrupts are pending in any privilege level
	mip & 0x40000 == 0x40000 : 0 				# Machine software interrupt is pending
	mip & 0x200000 == 0x200000 : 0 			# Machine timer interrupt is pending
	mip & 0x1000000 == 0x1000000 : 0 			# Machine external interrupt is pending

mip_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mip & 0x100000 == 0x100000 : 0 			# Supervisor timer interrupt is pending
	mip & 0x20000 == 0x20000 : 0  			# Supervisor software interrupt is pending
	mip & 0x800000 == 0x800000 : 0  			# Supervisor external interrupt is pending
    
mip_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mip & 0x7fff0000 == 0x00010000 : 0  			# Only user interrupts are pending
	mip & 0x10000 == 0x10000 : 0  			# User software interrupt is pending
	mip & 0x80000 == 0x80000 : 0  			# User timer interrupt is pending
	mip & 0x400000 == 0x400000 : 0  			# User external interrupt is pending

#####################################################################################################################################################################################

mcause:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause >> 8) & 0x01 == 0x01 : 0			# Exception or interrupt was caused by an instruction
	(mcause >> 8) & 0x01 == 0x00 : 0			# Exception or interrupt was caused by a system event
	(mcause & 0xff) == 0x00 : 0				# Instruction address misaligned exception
	(mcause & 0xff) == 0x01 : 0				# Instruction access fault exception
	(mcause & 0xff) == 0x02 : 0				# Illegal instruction exception
	(mcause & 0xff) == 0x03 : 0				# Breakpoint exception
	(mcause & 0xff) == 0x04 : 0				# Load address misaligned exception
	(mcause & 0xff) == 0x05 : 0				# Load access fault exception
	(mcause & 0xff) == 0x06 : 0				# Store/AMO address misaligned exception
	(mcause & 0xff) == 0x07 : 0				# Store/AMO access fault exception
	(mcause & 0xff) == 0x08 : 0				# Environment call from U-mode exception
	(mcause & 0xff) == 0x09 : 0				# Environment call from S-mode exception
	(mcause & 0xff) == 0x0a : 0				# Environment call from M-mode exception
	(mcause & 0xff) == 0x0b : 0				# Instruction page fault exception
	(mcause & 0xff) == 0x0c : 0				# Load page fault exception
	(mcause & 0xff) == 0x0d : 0				# Store/AMO page fault exception
	(mcause >> 10) & 0x01 == 0x01 : 0			# Exception or interrupt was caused by an instruction fetch
	(mcause >> 10) & 0x01 == 0x00 : 0			# Exception or interrupt was caused by a data access
	(mcause >> 3) & 0x07 == 0x00 : 0 			# Exception or interrupt occurred at machine level (M-mode)
	(mcause & 0xff) == 0x32 : 0				# Timer interrupt was caused by a compare match on timer 0
	(mcause & 0xff) == 0x33 : 0  				# Timer interrupt was caused by a compare match on timer 1
	(mcause & 0xff) == 0x34 : 0  				# Timer interrupt was caused by a compare match on timer 2
	(mcause & 0xff) == 0x35 : 0  				# Timer interrupt was caused by a compare match on timer 3
	(mcause & 0xff) == 0x42 : 0  				# Software interrupt was triggered by the mret instruction
	(mcause & 0xff) == 0x80 : 0 				# Machine mode interrupt was triggered by the wfi instruction
	(mcause & 0xff) == 0x81 : 0 				# Machine mode interrupt was triggered by the mcycle timer
	(mcause & 0xff) == 0x82 : 0 				# Machine mode interrupt was triggered by the minstret timer
	(mcause & 0xff) == 0x83 : 0 				# Machine mode interrupt was triggered by the mhpmcounter3 timer
	
	

mcause_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause & 0xff) == 0x84 : 0 				# Supervisor mode interrupt was triggered by the scycle timer
	(mcause & 0xff) == 0x85 : 0 				# Supervisor mode interrupt was triggered by the sinstret timer
	(mcause & 0xff) == 0x86 : 0 				# Supervisor mode interrupt was triggered by the shpmcounter3 timer
	(mcause & 0xff) == 0x40 : 0  				# Software interrupt was triggered by the sret instruction
	(mcause >> 3) & 0x07 == 0x01 : 0 			# Exception or interrupt occurred at supervisor level (S-mode)
    
mcause_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause & 0xff) == 0x88 : 0 				# User mode interrupt was triggered by the ucycle timer
	(mcause & 0xff) == 0x89 : 0 				# User mode interrupt was triggered by the uinstret timer
	(mcause & 0xff) == 0x8a : 0				# User mode interrupt was triggered by the uhpmcounter3 timer
	(mcause & 0xff) == 0x41 : 0  				# Software interrupt was triggered by the uret instruction
	(mcause >> 3) & 0x07 == 0x02 : 0 			# Exception or interrupt occurred at user level (U-mode)
	(mcause & 0xff) == 0x20 : 0				# User software interrupt

#####################################################################################################################################################################################
		
mcycle:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcycle == 0x0 : 0					# where the value in mcycle register is 0
	mcycle > 1000 : 0 					# More than 1000 cycles were executed
	mcycle > 10000 : 0					# More than 10000 cycles were executed
	mcycle > 100000 : 0					# More than 100000 cycles were executed	

#####################################################################################################################################################################################

minstret:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	minstret > 1000 : 0 					# More than 1000 instructions were executed in the last second
	minstret > 10000 : 0 					# More than 10000 instructions were executed in the last second
	minstret > 100000 : 0 					# More than 100000 instructions were executed in the last second

#####################################################################################################################################################################################

mhpmcounter:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mhpmcounter3 > 1000 : 0 				# More than 1000 memory accesses occurred
	mhpmcounter3 > 10000 : 0 				# More than 10000 memory accesses occurred
	mhpmcounter3 > 100000 : 0 				# More than 100000 memory accesses occurred

#####################################################################################################################################################################################

mhpmevent:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mhpmevent3 == 0x0 : 0					# where the value in mhpmevent3 register is 0.
	mhpmevent3 > 1000 : 0					# More than 1000 memory accesses occurred
	mhpmevent3 > 10000 : 0 				# More than 10000 memory accesses occurred
	mhpmevent3 > 100000 : 0 				# More than 100000 memory accesses occurred

#####################################################################################################################################################################################
	
mcounteren:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcounteren >> 0) & (mcounteren >> 1) & (mcounteren >> 2) == 0x00 : 0 # When the CY, TM, IR, or HPMn bit in the mcounteren register is clear, attempts to read the cycle, time, instret, or hpmcountern register while executing in S-mode or U-mode will cause an illegal instruction exception.
	mcounteren & 0x07 == 0x07 : 0				# checks that the three least significant bits are all 1
	mcounteren & 0x07 == 0x00 : 0				# checks that the three least significant bits are either all 0
    	mcounteren & 0x07 == 0x05 : 0				# for the next 3, checking that the three least significant bits are alternating 1s and 0s (e.g. 101, 010, or 011)
    	mcounteren & 0x07 == 0x02 : 0
    	mcounteren & 0x07 == 0x06 : 0
	
mcounteren_S and U mode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcounteren >> 0) & (mcounteren >> 1) & (mcounteren >> 2) == 0x00 : 0 # When the CY, TM, IR, or HPMn bit in the mcounteren register is clear, attempts to read the cycle, time, instret, or hpmcountern register while executing in S-mode or U-mode will cause an illegal instruction exception.

    	

#####################################################################################################################################################################################

mcountinhibit:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcountinhibit == 1 : 0					# checks that the value of the register is either 1
	mcountinhibit == 1 : 0					# checks that the value of the register is either 0
	mcountinhibit != 0 : 0					# checks that the value of the register is any value other than 0

#####################################################################################################################################################################################

mscratch:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mscratch == 0x12345678 : 0				# checks that the value of the mscratch CSR is 0x12345678
	mscratch >= 0x00000000 && mscratch <= 0xFFFFFFFF : 0	# checks that the value of the mscratch CSR is within the range of 0x00000000 to 0xFFFFFFFF, inclusive
	mscratch != 0xDEADBEEF : 0				# checks that the value of the mscratch CSR is not equal to 0xDEADBEEF	
	

#####################################################################################################################################################################################
	
mepc:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 10) & 0x01 == 0x01 : 0 			# Exception or interrupt was caused by an instruction fetch
	(mepc >> 10) & 0x01 == 0x00 : 0 			# Exception or interrupt was caused by a data access
	(mepc >> 3) & 0x07 == 0x00 : 0 			# Exception or interrupt occurred at machine level (M-mode)
	(mepc & 0x3) == 0x00 : 0 				# Instruction was aligned on a 4-byte boundary
	(mepc & 0x3) == 0x01 : 0 				# Instruction was aligned on a 2-byte boundary
	(mepc & 0x3) == 0x02 : 0 				# Instruction was aligned on a 1-byte boundary
	(mepc & 0x3) == 0x03 : 0 				# Instruction was unaligned
	(mepc >> 2) & 0x01 == 0x00 : 0 			# Instruction was a load or store instruction
	(mepc >> 2) & 0x01 == 0x01 : 0 			# Instruction was an arithmetic or logical instruction

mepc_Smode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 3) & 0x07 == 0x01 : 0 			# Exception or interrupt occurred at supervisor level (S-mode)
	
mepc_Umode:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 3) & 0x07 == 0x02 : 0 			# Exception or interrupt occurred at user level (U-mode)

#####################################################################################################################################################################################

mtval:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 			
  mnemonics: 							
    csrrw: 0
    csrrs: 0
  csr_comb:							
  	mtval == 0 : 0 					# checks that the value written to or modified in the mtval CSR is 0. This could be useful for verifying that the mtval CSR is being used correctly in your design or implementation.
  	
  	
mtval_multiple_of_4:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
	mtval % 4 == 0: 0					# coverpoint checks that the value written to or modified in the mtval CSR is a multiple of 4.
  	
  	
mtval_multiple_of_4_not_8:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*);
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
	mtval % 4 == 0 and mtval % 8 != 0: 0			# checks that the value written to or modified in the mtval CSR is a multiple of 4 but not a multiple of 8
  	
#####################################################################################################################################################################################

mconfigptr:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
  	mconfigptr == 0x12345678 : 0				# checks that the value of the mconfigptr CSR is 0x12345678				
  	mconfigptr % 4 == 0 : 0				# checks that the value of the mconfigptr CSR is a multiple of 4
  	mconfigptr >= 0x80000000 && mconfigptr < 0x90000000 : 0	# checks that the value of the mconfigptr CSR is within the range of 0x80000000 to 0x8FFFFFFF, inclusive 
  	mconfigptr & 0xFFFFF000 == 0x12345000 : 0		# checks that the value of the mconfigptr CSR is aligned to a 1MB boundary, with the address 0x12345000 being the base address of the memory region
  	
  	
#####################################################################################################################################################################################

menvcfg:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	menvcfg == 0x12345678 : 0 				# checks that the value of the menvcfg CSR is 0x12345678
	menvcfg >= 0x00000000 && menvcfg <= 0xFFFFFFFF : 0	# checks that the value of the menvcfg CSR is within the range of 0x00000000 to 0xFFFFFFFF, inclusive
	menvcfg != 0xDEADBEEF : 0				# checks that the value of the menvcfg CSR is not equal to 0xDEADBEEF
	

#####################################################################################################################################################################################

mtime:    
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	 mtime >= 0x0000000000000000 && mtime <= 0xFFFFFFFFFFFFFFFF : 0			# checks that the value of the mtime CSR is within the range of 0x0000000000000000 to 0xFFFFFFFFFFFFFFFF, inclusive
    	(mtime >> 4) & 0x1 == 0x1 : 0				# checks that the fifth bit of the mtime CSR is set to 1 and the sixth bit is set to 0
	mtime != 0xDEADBEEFDEADBEEF : 0			# checks that the value of the mtime CSR is not equal to 0xDEADBEEFDEADBEEF
	mtime == 0x12345678ABCDEF : 0				# checks that the value of the mtime CSR is 0x12345678ABCDEF
    	mtime % 4 == 0 : 0					# checks that the value of the mtime CSR is a multiple of 4

#####################################################################################################################################################################################

mseccfg:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mseccfg >> 4) & 0x1 == 0x1 : 0			# checks that the fifth bit of the mseccfg CSR is set to 1
    	(mseccfg >> 5) & 0x1 == 0x0 : 0			# checks that the sixth bit of the mseccfg CSR is set to 0
	mseccfg != 0xDEADBEEF : 0				# checks that the value of the menvcfg CSR is not equal to 0xDEADBEEF
	mseccfg == 0x0 : 0					# checks that the value of the mseccfg CSR is 0
    	mseccfg % 4 == 0 : 0					# checks that the value of the mseccfg CSR is a multiple of 4

#####################################################################################################################################################################################


pmpcfg:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  csr_comb:
    pmpcfg0 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg0
    pmpcfg0 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg0
    (pmpcfg0 >> 8) & 0x80 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg0
    (pmpcfg0 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg0
    (pmpcfg0 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg0
    (pmpcfg0 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg0
    (pmpcfg0 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg0
    (pmpcfg0 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg0
    pmpcfg1 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg1
    pmpcfg1 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg1
    (pmpcfg1 >> 8) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg1
    (pmpcfg1 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg1
    (pmpcfg1 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg1
    (pmpcfg1 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg1
    (pmpcfg1 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg1
    (pmpcfg1 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg1
    pmpcfg2 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg2
    pmpcfg2 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg2
    (pmpcfg2 >> 8) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg2
    (pmpcfg2 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg2
    (pmpcfg2 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg2
    (pmpcfg2 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg2
    (pmpcfg2 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg2
    (pmpcfg2 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg2
    pmpcfg3 & 0x60 == 0 : 0			# Check if [6:5] WARL field is hardwired to zero always, for pmp0cfg3
    pmpcfg3 & 0x80 == 0x80 : 0			# Check if lock bit is high for pmp0cfg3
    (pmpcfg3 >> 8) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp1cfg3
    (pmpcfg3 >> 8) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp1cfg3
    (pmpcfg3 >> 16) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp2cfg3
    (pmpcfg3 >> 16) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp2cfg3
    (pmpcfg3 >> 24) & 0x60 == 0 : 0		# Check if [6:5] WARL field is hardwired to zero always, for pmp3cfg3
    (pmpcfg3 >> 24) & 0x80 == 0x80 : 0		# Check if lock bit is high for pmp3cfg3



pmptor:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  csr_comb:
    (pmpcfg0 >> 16) & 0x18 == 0x08 : 0		# Check if we are in TOR mode
    (pmpcfg0 >> 16) & 0x01 == 0x01 : 0		# Check if R=1
    (pmpcfg0 >> 16) & 0x02 == 0x02 : 0		# Check if W=1
    (pmpcfg0 >> 16) & 0x04 == 0x04 : 0		# Check if X=1
    (pmpcfg0 >> 16) & 0x01 == 0x00 : 0		# Check if R=0
    (pmpcfg0 >> 16) & 0x02 == 0x00 : 0		# Check if W=0
    (pmpcfg0 >> 16) & 0x04 == 0x00 : 0		# Check if X=0

pmpna4:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  csr_comb:
    (pmpcfg0 >> 16) & 0x18 == 0x10 : 0		# Check if we are in NA4 mode
    (pmpcfg0 >> 16) & 0x01 == 0x01 : 0		# Check if R=1
    (pmpcfg0 >> 16) & 0x02 == 0x02 : 0		# Check if W=1
    (pmpcfg0 >> 16) & 0x04 == 0x04 : 0		# Check if X=1
    (pmpcfg0 >> 16) & 0x01 == 0x00 : 0		# Check if R=0
    (pmpcfg0 >> 16) & 0x02 == 0x00 : 0		# Check if W=0
    (pmpcfg0 >> 16) & 0x04 == 0x00 : 0		# Check if X=0


pmpnapot:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config: 
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=True; def rvtest_mtrap_routine=True
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
    (pmpcfg0 >> 16) & 0x18 == 0x18 : 0		# Check if we are in NAPOT Mode?
    (pmpcfg0 >> 16) & 0x01 == 0x01 : 0		# Check if R=1
    (pmpcfg0 >> 16) & 0x02 == 0x02 : 0		# Check if W=1
    (pmpcfg0 >> 16) & 0x04 == 0x04 : 0		# Check if X=1
    (pmpcfg0 >> 16) & 0x01 == 0x00 : 0		# Check if R=0
    (pmpcfg0 >> 16) & 0x02 == 0x00 : 0		# Check if W=0
    (pmpcfg0 >> 16) & 0x04 == 0x00 : 0		# Check if X=0

misalign-lh:
  cond: check ISA:=regex(.*I.*Zicsr.*)
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  mnemonics:
    lh: 0
  val_comb:
    'ea_align == 1': 0

misalign-lhu:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    lhu: 0
  val_comb:
    'ea_align == 1': 0


misalign-lw:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    lw: 0
  val_comb:
    'ea_align == 1': 0
    'ea_align == 2': 0
    'ea_align == 3': 0

misalign-sh:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    sh: 0
  val_comb:
    'ea_align == 1': 0

misalign-sw:
  config:
    - check ISA:=regex(.*I.*); check hw_data_misaligned_support:=True
    - check ISA:=regex(.*I.*Zicsr.*); check hw_data_misaligned_support:=False; def rvtest_mtrap_routine=True
  cond: check ISA:=regex(.*I.*Zicsr.*)
  mnemonics:
    sw: 0
  val_comb:
    'ea_align == 1': 0
    'ea_align == 2': 0
    'ea_align == 3': 0

misalign2-jalr:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    jalr: 0
  val_comb:
    'imm_val%2 == 1 and ea_align == 2': 0


misalign1-jalr:
  config: 
    - check ISA:=regex(.*I.*)
  mnemonics:
    jalr: 0
  val_comb:
    'imm_val%2 == 0 and ea_align == 1': 0


misalign-jal:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    jal: 0
  val_comb:
    'ea_align == 2': 0

misalign-bge:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bge: 0
  val_comb:
    ' rs1_val>rs2_val and ea_align == 2': 0

misalign-bgeu:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bgeu: 0
  val_comb:
    ' rs1_val>rs2_val and ea_align == 2': 0

misalign-blt:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    blt: 0
  val_comb:
    ' rs1_val<rs2_val and ea_align == 2': 0

misalign-bltu:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bltu: 0
  val_comb:
    ' rs1_val<rs2_val and ea_align == 2': 0

misalign-bne:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    bne: 0
  val_comb:
    ' rs1_val!=rs2_val and ea_align == 2': 0

misalign-beq:
  config:
    - check ISA:=regex(.*I.*C.*)
    - check ISA:=regex(.*I.*Zicsr.*); check ISA:=regex(^[^C]+$); def rvtest_mtrap_routine=True 
  cond: check ISA:=regex(.*I.*)
  mnemonics:
    beq: 0
  val_comb:
    ' rs1_val==rs2_val and ea_align == 2': 0
